
export interface SimpleButton {
  text: string;
  url?: string;
  callback_data?: string;
}

export interface SimpleMessage {
  text: string;
  buttons?: SimpleButton[][];
}

const generateUUID = () => crypto.randomUUID();

/**
 * Converts a simple array of message objects into an advanced n8n workflow JSON string
 * with a router (Switch node) for handling callbacks.
 * @param simpleJson An array of message objects generated by the AI.
 * @returns A stringified n8n workflow JSON.
 */
export function convertToN8nJson(simpleJson: SimpleMessage[]): string {
    const nodes: any[] = [];
    const connections: any = {};
    const credentials = {
        telegramApi: {
            id: 'YOUR_TELEGRAM_CREDENTIALS_ID', // Placeholder
            name: 'Telegram Credentials',
        },
    };

    // 1. Telegram Trigger Node
    const triggerNodeId = generateUUID();
    nodes.push({
        parameters: { events: 'message,callback_query' },
        id: triggerNodeId,
        name: 'Telegram Trigger',
        type: 'n8n-nodes-base.telegramTrigger',
        typeVersion: 1,
        position: [250, 300],
        webhookId: generateUUID(),
        credentials,
    });

    // 2. Switch Node for Routing
    const switchNodeId = generateUUID();
    const switchNode = {
        parameters: {
            fieldToMatch: '={{ $json.message?.text ?? $json.callback_query?.data }}',
            rules: {
                values: [{ operation: 'startsWith', value1: '/start' }] // Rule for /start
            },
            options: {}
        },
        id: switchNodeId,
        name: 'Router',
        type: 'n8n-nodes-base.switch',
        typeVersion: 1,
        position: [500, 300],
    };
    connections[triggerNodeId] = { main: [[{ node: switchNodeId, input: 'main' }]] };

    // 3. Create Message Nodes and Logic Branches
    let lastNodeIdInPrevBranch: string | null = null;
    let nextBranchStartIndex = 0;
    
    // Find all callback_data to create routing rules in advance
    simpleJson.forEach((message) => {
        if (message.buttons) {
            message.buttons.flat().forEach(button => {
                if (button.callback_data) {
                    switchNode.parameters.rules.values.push({
                        operation: 'equals',
                        value1: button.callback_data,
                    });
                }
            });
        }
    });

    nodes.push(switchNode);
    connections[switchNodeId] = { main: [[]] };
    
    let currentSwitchOutputIndex = 0;

    // Connect /start (output 0) to the first message
    if (simpleJson.length > 0) {
        const firstMessageNodeId = generateUUID();
        connections[switchNodeId].main[currentSwitchOutputIndex] = [{ node: firstMessageNodeId, input: 'main' }];
        lastNodeIdInPrevBranch = firstMessageNodeId;
    }
    currentSwitchOutputIndex++;

    let lastMessageNodeId: string | null = null;
    
    simpleJson.forEach((message, index) => {
        const nodeId = (index === 0 && lastNodeIdInPrevBranch) ? lastNodeIdInPrevBranch : generateUUID();
        const nodePosition = [750 + (index * 250), 150 + (index * 50)];

        const telegramNode = {
            parameters: {
                chatId: '={{ $json.message?.chat.id ?? $json.callback_query.message.chat.id }}',
                text: message.text,
                additionalFields: {}
            },
            id: nodeId,
            name: `Msg ${index + 1}`,
            type: 'n8n-nodes-base.telegram',
            typeVersion: 1,
            position: nodePosition,
            credentials,
        };

        if (message.buttons) {
            telegramNode.parameters.additionalFields = {
                reply_markup: { inline_keyboard: message.buttons }
            };

            // Connect callbacks from this message to the next message block
            message.buttons.flat().forEach(button => {
                if (button.callback_data) {
                    const nextMessageNodeId = (index + 1 < simpleJson.length) ? generateUUID() : null;
                    if (nextMessageNodeId) {
                         connections[switchNodeId].main[currentSwitchOutputIndex] = [{ node: nextMessageNodeId, input: 'main' }];
                         lastNodeIdInPrevBranch = nextMessageNodeId;
                    }
                    currentSwitchOutputIndex++;
                }
            });
        }
        
        nodes.push(telegramNode);
        
        if (lastMessageNodeId && !simpleJson[index - 1].buttons) {
             // Connect sequentially if the previous message had no buttons
             connections[lastMessageNodeId] = { main: [[{ node: nodeId, input: 'main' }]] };
        } else if (index > 0 && simpleJson[index - 1].buttons) {
            // This is the start of a new branch, it's already connected from the switch.
            // But we need to update its ID if we pre-generated it.
            const preGeneratedId = lastNodeIdInPrevBranch;
            if (preGeneratedId) {
                telegramNode.id = preGeneratedId;
            }
        }
        
        lastMessageNodeId = telegramNode.id;
    });

    const n8nWorkflow = { nodes, connections };
    return JSON.stringify(n8nWorkflow, null, 2);
}
